; CLI_CMD: Protocol controlled command dispatcher
; Author: Vladimir Sustek, License: free for anything
; Date: 09. Feb 2022, Platform KCPSM6 (PicoBlaze)
;
; The code uses specific KCPSM6 commands and therefore
; may be unportable
;
; Purpose: Module is intended to read received string
; content (e.g. UART) and upon the input determine the
; action. Module is not calling any peripheral layer
; therefore each action is processed by sending data 
; to output port. Also, reading actions are directly 
; accessing input port.
;
; Be careful when adding a new command to do not write
; any register needed for command parsing/dispatching.
;
; Necessary dependencies: RAM_BUFF.psm
;
; Functions: 

; 1) String functions for comparing input:

; CMD_TCKGET, CMD_DA1STV, CMD_DA0STI, CMD_RFSMOD, CMD_LCDSTB
; + CMD_DUMMY (dummy memory area ocuppied by the function)
;
; 2) Action functions (called upon the input request)
;
; RSP_DA1STV, RSP_DA0STI, RSP_RFSMOD, RSP_TCKGET, RSP_LCDSTB, RSP_ERR
;
; 3) Interface function (only called by upper layer/application)
; 
; CHECK_RECEIVED
;
; 4) Internal operations
;
; COMPARE_CMD, GET_ARG, PRINT_ARG, ASCII2HEX
;
;
; Protocol description:
;-----------------------------------------
; EACH input commands must have length of 15 characters:
; 
; - two characters of the peripheral name e.g. D1 (DAC1)
; - underscore delimiter '_' = 0x5F
; - two characters of the action name e.g. SI (Set Voltage)
; - underscore delimiter '_' = 0x5F
; - eight characters of the argument e.g. 00001111
; - termination of the string by LF (Line Feed) = 0x0A 
;
; Supported commands:
;
; D1_SV_XXXX0123 -> applicable D1_SV_00009999 : D1_SV_00000000
; set DAC1 voltage => 0.067mV * argument (max cca 3000mV)
;
; D0_SI_X0123456 -> applicable D0_SI_01FFFFFF : D0_SI_00000000
; set DAC0 frequency => 3.57Hz * argument (max 120MHz)

; RF_MD_XXXXXXX1 -> applicable RF_MD_00000001 : RF_MD_00000005
;
; LC_SB_XXXX2021 -> applicable RF_MD_000010?? : RF_MD_00002F??
; used to control initialized 16x2 display FDCC1602N-FLYYBW-91LE
; by setting ASCII character "??" into position 10 (1st line 0th 
; char) up to position 20 (second line 15th character)
;
; TC_GT_XXXXXXXX -> no meaningful argument needed, just padding
; get 32-bit tick value which is each 1ms incremented
;
; Response:
; Reponse length is always 10 including terminating LF
;
; 
;
CONSTANT CMD_LNG, 06
CONSTANT ARG_LNG, 08
CONSTANT CMD_OK, 55
CONSTANT CMD_ER, AA

; INPUT

CONSTANT sTickRead31_24Port, 03
CONSTANT sTickRead23_16Port, 04
CONSTANT sTickRead15_08Port, 05
CONSTANT sTickRead07_00Port, 06

; OUTPUT
CONSTANT cTxUARTDataPort, 01
CONSTANT cDAC1_07_00Port, 03
CONSTANT cDAC1_15_08Port, 04

CONSTANT cDAC0_31_24Port, 08
CONSTANT cDAC0_23_16Port, 07
CONSTANT cDAC0_15_08Port, 06
CONSTANT cDAC0_07_00Port, 05

CONSTANT cRFModePort, 09
CONSTANT cSystemResetPort, 0A

CONSTANT cLCDPort1_00, 10
CONSTANT cLCDPort2_15, 2F

CONSTANT cUNKNOWN_COMAND, AA
CONSTANT cCORRECT_COMMAND, 55

;-----------------------------------------
; EACH commands needs always content of 15 characters:
; 
; - two characters of the peripheral name e.g. D1 (DAC1)
; - underscore delimiter '_' = 0x5F
; - two characters of the action name e.g. SI (Set Voltage)
; - underscore delimiter '_' = 0x5F
; - eight characters of the argument e.g. 00001111
; - termination of the string by LF (Line Feed) = 0x0A 
;
; - system always replies with response of length 10
;
; D1_SV_XXXX0123<LF> -> applicable D1_SV_00009999 : D1_SV_00000000
; set DAC1 voltage => 0.067mV * argument (max cca 3000mV)

; Awaited response: DA1:V-set<LF>
;
; D0_SI_X0123456<LF> -> applicable D0_SI_01FFFFFF : D0_SI_00000000
; set DAC0 frequency => 3.57Hz * argument (max 120MHz)

; Awaited response: DA0:I-set<LF>
;
; RF_MD_XXXXXXX1 -> applicable RF_MD_00000000 : AU_SR_00000006
;
; 0 - No DAC0 signal and amplifier stage turned off
; 1 - cRFTestSine
; 2 - cRFTestSinePilot
; 3 - cRFMono
; 4 - cRFMonoPilot
; 5 - cRFMonoStereo
; 6 - cRFMonoStereoPilot
;
; Awaited response: RFS:M-set<LF>
;
; TC_GT_XXXXXXXX -> no meaningful argument needed, just padding
; get 32-bit tick value which is each 1ms incremented
;
; Awaited response: STCK:AABBCCDD<LF> 
; !!! note that response payload has length of 4-bytes - hex, not 8-bytes !!!
;
; LC_SB_XXXX2020 -> applicable RF_MD_0000XXYY : AU_SR_0000XXYY where YY is ASCII
; 
; XX stands for position: LINE(1 or 2) and CHARACTER (0-F) and YY FOR ASCII character
;
; Awaited response LC_DB:XXYYY<LF>
; 
; 
; Fuctions headers to be checked against received content
STRING STCK_GET$, "TC_GT_"
CMD_TCKGET: LOAD&RETURN s6, STCK_GET$

STRING SDA1_STV$, "D1_SV_"
CMD_DA1STV: LOAD&RETURN s6, SDA1_STV$
	  
STRING SDA0_STI$, "D0_SI_"
CMD_DA0STI: LOAD&RETURN s6, SDA0_STI$

STRING SRFS_MOD$, "RF_MD_"
CMD_RFSMOD: LOAD&RETURN s6, SRFS_MOD$

STRING SLCD_STB$, "LC_SB_"
CMD_LCDSTB: LOAD&RETURN s6, SLCD_STB$


; This function is not intended to be called
; neither anyhow used, but by placing this 
; function here I eliminated weird behaviour
; for calling function CMD_RFSMOD, my theory
; is that there was some conflict with address
; of the last function and other used memspace
; therefore this padding by the CMD_DUMMY makes
; a border between functions and the rest
STRING SDUMMY$, "DUMMY_"
CMD_DUMMY: LOAD&RETURN s6, SDUMMY$

;------------------------------------------
; Supported functions and their HW actions
;------------------------------------------


; Function sets DA1 voltage by shifting out
; the 16-bit value in two 8-bit chunks
; Therefore, buffering at the output is expected
; Function finished with UART message
STRING SRDA1_STV$, "DA1:V-set"
RSP_DA1STV: CALL UART_TX_CLEAR
						
			CALL READ_ARG_15_08
			OUTPUT BUFF_DATA, cDAC1_15_08Port
			CALL READ_ARG_07_00
			OUTPUT BUFF_DATA, cDAC1_07_00Port
			
			OUTPUTK SRDA1_STV$, 1
		    OUTPUTK LF, 1
			
			RETURN

; Function sets DA0 phase increment by shifting out
; the 32-bit value in four 8-bit chunks
; Therefore, buffering at the output is expected
; Function finished with UART message	
STRING SRDA0_SET$, "DA0:I-set"
RSP_DA0STI: CALL UART_TX_CLEAR

			CALL READ_ARG_31_24
			OUTPUT BUFF_DATA, cDAC0_31_24Port
			CALL READ_ARG_23_16
			OUTPUT BUFF_DATA, cDAC0_23_16Port
			CALL READ_ARG_15_08
			OUTPUT BUFF_DATA, cDAC0_15_08Port
			CALL READ_ARG_07_00
			OUTPUT BUFF_DATA, cDAC0_07_00Port
			OUTPUTK SRDA0_SET$, 1
		    OUTPUTK LF, 1
			
			RETURN

; Function sets RF Mode by setting 8-bit value
; Value may be immediately used - no chunks
; Function finished with UART message
STRING SRRFS_MOD$, "RFS:M-set"
RSP_RFSMOD: CALL UART_TX_CLEAR

			CALL READ_ARG_07_00
			OUTPUT BUFF_DATA, cRFModePort
			
			OUTPUTK SRRFS_MOD$, 1
		    OUTPUTK LF, 1
			
			RETURN

; Function reads milisecond counter and directly
; sends out the value as a part of the UART message
STRING SRTCK_GET$, "STCK:"
RSP_TCKGET: CALL UART_TX_CLEAR

			OUTPUTK SRTCK_GET$, 1

			INPUT BUFF_DATA, sTickRead31_24Port
			OUTPUT BUFF_DATA, cTxUARTDataPort
			INPUT BUFF_DATA, sTickRead23_16Port
			OUTPUT BUFF_DATA, cTxUARTDataPort
			INPUT BUFF_DATA, sTickRead15_08Port
			OUTPUT BUFF_DATA, cTxUARTDataPort
			INPUT BUFF_DATA, sTickRead07_00Port
			OUTPUT BUFF_DATA, cTxUARTDataPort

			OUTPUTK LF, 1
			
			RETURN


; Function gets argument byte 15_08 as an display address
; and 07_00 as an ASCII character and sends the character
; into the appropriate port.
STRING SRLCD_STB$, "LCDB:"		
RSP_LCDSTB: CALL UART_TX_CLEAR
			OUTPUTK SRLCD_STB$, 1
		
			CALL READ_ARG_15_08
			LOAD s6, BUFF_DATA
			OUTPUT s6, TX_UART_PORT
			
			CALL READ_ARG_07_00
			OUTPUT BUFF_DATA, (s6)
			OUTPUT BUFF_DATA, TX_UART_PORT

			OUTPUTK LF, 1
			
			RETURN
		
; Function sends out UART message signalizing error
STRING SINPERR$,   "INPUTERR!"
RSP_GENERR:     	CALL UART_TX_CLEAR
					OUTPUTK SINPERR$, 1
					OUTPUTK LF, 1
					RETURN	
;--------------------------------------------------
;--------------------------------------------------

; Main function to be called by upper layer
;
; Algorithm gradually loads addresses of the
; functions into registers:
;           s3 + s2 - string returning
;           s1 + s0 - action fuction
;
; because s3 - s0 is used by the COMPARE_CMD
; and in case received string matches CMD string the
; action represented as the RSP is called
;
; always, the BUFF_HEAD is saved, because buffer
; is loaded and controlled for each command
; 
; function sets in the beginning the cUNKNOWN_COMAND
; constant, which is affected in the COMPARE_CMD
; in case the input string was awaited and invoked
; 
CHECK_RECEIVED:	LOAD s8, cUNKNOWN_COMAND
				LOAD s7, BUFF_HEAD

				LOAD s3, CMD_TCKGET'upper
				LOAD s2, CMD_TCKGET'lower
				LOAD s1, RSP_TCKGET'upper
				LOAD s0, RSP_TCKGET'lower
				CALL COMPARE_CMD
				
				LOAD BUFF_HEAD, s7

				LOAD s3, CMD_DA1STV'upper
				LOAD s2, CMD_DA1STV'lower
				LOAD s1, RSP_DA1STV'upper
				LOAD s0, RSP_DA1STV'lower	
				CALL COMPARE_CMD
				
				LOAD BUFF_HEAD, s7
				
				LOAD s3, CMD_DA0STI'upper
				LOAD s2, CMD_DA0STI'lower
				LOAD s1, RSP_DA0STI'upper
				LOAD s0, RSP_DA0STI'lower
				CALL COMPARE_CMD
				
				LOAD BUFF_HEAD, s7
				
				LOAD s3, CMD_RFSMOD'upper
				LOAD s2, CMD_RFSMOD'lower
				LOAD s1, RSP_RFSMOD'upper
				LOAD s0, RSP_RFSMOD'lower
				CALL COMPARE_CMD

				LOAD BUFF_HEAD, s7
				
				LOAD s3, CMD_LCDSTB'upper
				LOAD s2, CMD_LCDSTB'lower
				LOAD s1, RSP_LCDSTB'upper
				LOAD s0, RSP_LCDSTB'lower
				CALL COMPARE_CMD
				
				COMPARE s8, cCORRECT_COMMAND
				CALL NZ, RSP_GENERR
			
				CALL INIT_BUFF
				RETURN				
			
;--------------------------------------------------

; The most important function which goes in cycle/loop through received string
; and compares the characters with known string. In case of unknown command
; the function immediately returns. In case of correct command, but incorrect
; argument length, function also invokes no action. In case of correct command
; and correct argument length, an appropriate action is invoked and cCORRECT_COMMAND set.

COMPARE_CMD:  LOAD s4, CMD_LNG ; length of string for the counter = number of the loop's cycles
cycle:		  CALL@ (s3, s2) ; call the routine which returns checked string, pointing on 1st char
			  OR s4, 00 ; redudant OR to return Z in context of the s4 (loop's counter)
			  JUMP Z, endofstr ; so, if end of loop (counter = 0), jump to check last character
			  CALL READ_BUFF; otherwise, read (fetch) received character (UART)
			  COMPARE s6, BUFF_DATA ; check receveived against string (character) retreived upper
			  RETURN NZ ; if character does not fit, leave - without any notice
			  SUB s4, 01 ; bute if if yes, decrement loop's counter
			  ADD s2, 01 ; increment routines address to get/test another char
			  JUMP cycle ; repeat the loop - to check another received character
			  
endofstr:	  LOAD s4, BUFF_TAIL; get buff tail (index of the string's begin)
			  SUB s4, BUFF_HEAD; get buff head (index of the string's end)
			  SUB s4, 01; decrement to exluced LF termination
			  COMPARE s4, ARG_LNG ; is length as the expected argument lentgh?
			  JUMP Z, match ; 1 or 0 returned in s0
			  LOAD s4, 00
			  RETURN; else return
			  		  
match:		  CALL GET_ARG; retrieve argument
			  CALL@ (s1, s0); call the function
			  LOAD s8, cCORRECT_COMMAND
			  RETURN
			  
;--------------------------------------------------

; Function to go through the 8-characters string argument
; and further convert it into the 32-bit (4-byte) number 
; Finally, all is stored in the RAM (ADRARG_31_24 - ADRARG_07_00)
;
GET_ARG:	  LOAD s4, ADRARG_31_24
iter32b:	  CALL READ_BUFF
			  CALL ASCII2HEX
			  LOAD s5, BUFF_DATA
			  SL0 s5
			  SL0 s5
			  SL0 s5
			  SL0 s5  
			  CALL READ_BUFF
			  CALL ASCII2HEX
			  ADD s5, BUFF_DATA
			  
			  STORE s5, (s4)	  
			  ADD s4, 01
			  
			  JUMP NC, iter32b
			  RETURN Z

; Function to convert character into hex number	("A" -> 0xA)
ASCII2HEX:    SUB BUFF_DATA, 30
			  COMPARE BUFF_DATA, LF
			  RETURN C
			  SUB BUFF_DATA, 07
			  COMPARE BUFF_DATA, 10
			  RETURN C
			  SUB BUFF_DATA, 20
			  RETURN

			  
; PRINT_ARG:    CALL READ_ARG_31_24
			  ; OUTPUT BUFF_DATA, cTxUARTDataPort
			  ; CALL READ_ARG_23_16
			  ; OUTPUT BUFF_DATA, cTxUARTDataPort
			  ; CALL READ_ARG_15_08
			  ; OUTPUT BUFF_DATA, cTxUARTDataPort
			  ; CALL READ_ARG_07_00
			  ; OUTPUT BUFF_DATA, cTxUARTDataPort
			  ; OUTPUTK LF, 1
			  ; RETURN